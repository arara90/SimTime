# 개발과정6

## [react] Modal Modal Modal!

#### 목표

생각보다 Modal을 많이 사용하게 된다. 하지만 그 때마다 Modal open/close 로직을 심어야 하는 반복되는 과정이 너무너무너무 지겨워서 Modal의 상태를 전 화면에서 공유할 수 있도록 만들고 싶어졌다.

 현재 하고 있는 방식은 Modal관련 state, 함수들과 {isModalOpen&&..} 부분을 항상 복붙해서 Modal이 필요한 Component에 복붙했다. (아래 코드 참고)

```
 function Friends(props) {
  const [isModalOpen, setIsOpenModal] = useState(false);
  const [targetModal, setTargetModal] = useState("friend"); //friend, group
 
 
  const handleOpenModal = (target) => {
    setTargetModal(target);
    setIsOpenModal(true);
  };

  const handleCloseModal = () => {
    setIsOpenModal(false);
  };
  
 return (
  <Wrap>
      <Section bottom="30px">
        <SectionTitle>
          <Header type="h3" color="MAIN_COLOR">Friends</Header>
          <StyledSearch width="125px" desc="Find a friend" height="25px" />
        </SectionTitle>
        .
        .
        생략
        .
        .
 		{isModalOpen && (
          <ModalPortal
            children={
              <Modal onClose={handleCloseModal}>
                {targetModal == "group" ? <div>group</div> : <div>member</div>}
              </Modal>
            }
          ></ModalPortal>)}
  </Wrap>
 );
      
      
```



#### 시도

Redux로 관리할까 생각도 해봤지만, Redux는 서버와 주고 받는 데이터를 위한 용도로만 남겨두고 싶다.

(추가 읽을거리 - https://blueshw.github.io/2017/06/26/presentaional-component-container-component/)

Modal open/close 기능은 오직 UI문제이니 react에서 제공하는 Context를 사용해보기로 했다.

리덕스의 state가 복잡해지는 것을 방지하고, 기능을 구분할 수 있으며 Context 연습용도(!)로 제격이다.



구글링 하자마자 결과 상단에서 좋은 글 발견

* [Your next React Modal with your own "useModal" Hook & Context API.](https://dev.to/alexandprivate/your-next-react-modal-with-your-own-usemodal-hook-context-api-3jg7)

content로 component를 넘겨줄 수 있을지만 확인이 되면, 완벽하게 원하는 방식이다. 이미 ModalPortal과 Modal 디자인은 되어있는 상태이니 빠르게 시도해보자.



#### 결과 

매우 성공적! 속이 다 시원하다! 거의 그대로 했는데  바로 성공했다. 적용 코드는 아래와 같다.



##### 1)useModal.js

```react
import React from "react";

export default () => {
  let [modal, setModal] = React.useState(false);
  let [modalContent, setModalContent] = React.useState("I'm the Modal Content");

  let handleModal = (content = false) => {
    setModal(!modal);
    if (content) {
      setModalContent(content);
    }
  };

  let closeModal = (content = false) => {
    setModal(false);
    setModalContent(content);
  };

  let openModal = (content = false) => {
    setModal(true);
    if (content) {
      setModalContent(content);
    }
  };

  return { modal, handleModal, openModal, closeModal, modalContent };
};

//openModal, closeModal 추가했다.
```



##### 2) modalContext.js

```react
import React from "react";
import useModal from "../hooks/useModal";
import ModalPortal from "../AtomicComponents/A-Atomics/Modal/ModalPortal";

let ModalContext;
let { Provider } = ( ModalContext = React.createContext()); 

let ModalProvider = ({ children }) => {
  let { modal, handleModal, openModal, closeModal, modalContent } = useModal();
  return (
    <Provider value={{ modal, handleModal, openModal, closeModal, modalContent }}>
      <ModalPortal />
      {children}
    </Provider>
  );
};

export { ModalContext, ModalProvider };

```



##### 3) App.js

ModalProvider 추가

```react
import { ModalProvider } from "../contexts/modalContext";

//..생략..//

class App extends Component {
//..생략..//
  render() {
    return (
      <Provider store={store}>
        <ModalProvider>
        <AlertProvider template={AlertTemplate} {...alertOptions}>
          <HashRouter>
            <Fragment>
              <GlobalStyle />
              <AppContents>
                <Header />
                <Alerts />
                <Switch>
                  <PrivateRoute exact path="/" component={CalendarPage} />
                  <Route exact path="/register" component={Register} />
                  <Route exact path="/login" component={Login} />
                  <Route exact path="/friends" component={Friends} />
                  <Route exact path="/mysimtime" component={MySimtime} />
                </Switch>
              </AppContents>
            </Fragment>
          </HashRouter>
        </AlertProvider>
        </ModalProvider>
      </Provider>
    );
  }
}

ReactDom.render(<App />, document.getElementById("app"));
```



##### 4) ModalPortal.js

```react
import React, { Fragment } from "react";
import ReactDOM from "react-dom";
import styled from "styled-components"
import { ModalContext } from "../../../contexts/modalContext";
import GlobalStyle from "../../GlobalStyle";

const MyModal = styled.div`
  background: rgba(0, 0, 0, 0.25);
  position: fixed;
  left: 0;
  top: 0;
  height: 100%;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 999;
`;

const ContentWrap = styled.div`
  border: solid 1px red;
  background: rgba(0, 0, 0, 0);
  width: auto;
  height: auto;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: flex-end;
  @media only screen and (max-width: 320px) {
    width: 98%;
    position: relative;
  }
`;

const ModalPotal = (props) => {
  const el = document.getElementById("app-modal");
  let { modalContent, handleModal, modal } = React.useContext(ModalContext);
  if (modal) {
    return ReactDOM.createPortal(
      <Fragment>
             <MyModal>
               <ContentWrap>
                  {modalContent}
               </ContentWrap>
             </MyModal>
         </Fragment>,
      el
    );
  } else return null;
};

export default ModalPotal;


// 이전코드
// const ModalPotal = (props) => {
//   const el = document.getElementById("app-modal");
//   return ReactDOM.createPortal(
//   <Fragment>
//       <MyModal>
//         <ContentWrap>
//             {props.children}
//         </ContentWrap>
//       </MyModal>
//   </Fragment>, el);
// };
```



##### 5) Component 사용 예시 - CalendarPage

Friends 보다 조금 더 정돈된 CalendarPage를 예시로 기록한다.

useContext를 통해 ModalContext의 handleModal과 closeModal을 가져왔다.

```react
//..생략..//
import EventMaker from "../D-Templates/Event/EventMaker"; //모달 Content
import { ModalContext } from "../../contexts/modalContext";

//..생략..//

function CalendarPage() {
  const { handleModal, closeModal } = React.useContext(ModalContext);

  useEffect(() => {});

  return (
    <Wrap>
      <LeftWrap>
        <StyledFilter />
        <StyledCalendar height="98%" />
      </LeftWrap>
      <RightWrap>
        <StyledDashedButton
          hasIcon={true}
          src="static/img/icons/edit2.png"
          onClick={() => handleModal(<EventMaker onClose={closeModal}/>)}
        >
          Add a new event
        </StyledDashedButton>
        <StyledDetail height="98%" />
      </RightWrap>
    </Wrap>
  );
}

export default CalendarPage;

```

 '새로운 이벤트 만들기' 버튼 onClick 이벤트 발생 시, handleModal이 EventMaker를 Content로 갖는 Modal을 오픈해준다.

 toggle 형식(!modal)의 handleModal만 사용하여  추가적인 코드 작성없이 깔끔하지만, CloseModal이 따로 있는게 직관적이고 확실한 동작을 나타낸다고 생각해서 closeModal 추가했다.  

 EventMaker(modalContent)가 이벤트 생성 완료 후 자체적으로 Modal을 닫을 수 있도록 CloseModal 함수를 props로 전달했다. EventMaker에서 다시 ModalContext를 import할 필요가 없어 간결해진다.



```react
<StyledDashedButton
          hasIcon={true}
          src="static/img/icons/edit2.png"
          onClick={() => handleModal(<EventMaker onClose={closeModal}/>)}
        >
          Add a new event
</StyledDashedButton>
```



이 글의 첫번째 코드블럭으로 돌아가  modal부분을 비교해보면 훨~~~씬 사용성이 좋아졌다.

더 훈련(!)해서 이런 공통적이고 반복적인 UI작업에 custom hook과 context를 적극 사용할 수 있도록 해야겠다.



## [django] Queryset을 이용한 Join

#django



드디어 초단순 CRUD 작업을 벗어나 단순 CRUD(!) 작업을 할 시간이 도래했다. 짝짝짜가ㅉㄱㄴㄻㄴㄹ 기쁘다.

누가 뭐래도 처음 sql을 접했을 때 가장 가슴 설레게 했던 아이(!)는 JOIN이 아닐까.. 어서 QuerySet으로 적용해보자.



### 목표

##### 친구목록에 user의 친구들 뿌려주기. 

- Realtionship 테이블에서 접속한 user의 친구의 id를 검색하고, 해당 친구의 정보를 Account Table에서 조회하여 username, email, profile_image를 얻어오자.



#### 참고 학습 문서

* [select_related와 prefetch_related](https://jupiny.com/2016/10/06/select_related-prefetch_related/)

  

#### select_related와 prefetch_related는 무엇인가

**select_related** 와 **prefetch_related** 는 하나의 QuerySet을 가져올 때, 미리 related objects들까지 다 불러와주는 함수이다. 비록 query를 복잡하게 만들긴 하지만, 그렇게 불러온 data들은 모두 cache에 남아있게 되므로 DB에 다시 접근해야 하는 수고를 덜어줄 수 있다. 이렇게 두 함수 모두 DB에 접근하는 수를 줄여, performance를 향상시켜준다는 측면에서는 공통점이 있지만, 그 방식에는 차이점이 있다.



#### select_related와 prefetch_related의 차이

먼저 **select_related** 은 SQL의 JOIN을 사용하는 특성상 *foreign-key* , *one-to-one* 와 같은 single-valued relationships에서만 사용이 가능하다는 한계가 있다.

아래와 같은 모델이 있다고 가정해보자.

```
from django.db import models
 
class Country(models.Model):
    name = models.CharField(max_length=10)
    def __str__(self):
        return self.name
 
class Person(models.Model):
    city = models.ForeignKey(City)
    name = models.CharField(max_length=10,)
    def __str__(self):
        return self.name
         
class Pet(models.Model):
    person = models.ForeignKey(Person)
    name = models.CharFieldmax_length=10)
    def __str__(self):
        return self.name
        
class Language(models.Model):
    person_set = models.ManyToManyField(Person)
    name = models.CharField(max_length=10)
    def __str__(self):
        return self.name
```

```
# Not use select_related()
pet = Pet.objects.get(id=1)
person = pet.person	
country = person.country


# Use select_related()
pet = Pet.objects.select_related('person__country').get(id=1)
person = pet.person
country = person.country


```

첫번째 방법으로 하면 총 DB에 세 번 접근하게 된다.

1. Pet 모델에서 id가 1번인 pet을 가져오기 위한 query
2. 그 pet의 person를 가져오기 위한 query
3. 그 person의 country를 가져오기 위한 query



하지만 두번째 방법으로 하면 Pet.objects.select_related('person__country').get(id=1)에서 이미 related objects(여기에서는 person, country)까지 다 뽑아와 cache에 저장해놓게 된다. 따라서 그 다음에는 person, country를 가져오기 위해 다시 DB에 접근하지 않고 cache에서 꺼내 쓰면 된다.



반면, **prefetch_related** 은 *foreign-key* , *one-to-one* 뿐만 아니라 *many-to-many* , *many-to-one* 등 모든 relationships에서 사용 가능하다.

여기서 Person의 모든 instance들과 그 instance들의 language_set들을 아래와 같이 모두 출력해야 한다고 가정하자.



> **Tom: Python Ruby**
> **Peter: Python Node.js Java**
> **John: Java C++ php**

```
# No use prefetch_related()
people = Person.objects.all()
for person in people:
    print(person.name+" : ", end="")
    for language in person.language_set.all():
        print(language.name+" ", end="")
    print("")


# Use prefetch_related()
people = Person.objects.all().prefetch_related('language_set')
for person in people:
    print(person.name+" : ", end="")
    for language in person.language_set.all():
        print(language.name+" ", end="")
    print("")

```



첫번째 경우에서는 Person.objects.all() 안에 있는 person마다 person.language_set.all() 이라는 query가 실행이 된다. 즉, person이 100개 있다면 person.language_set.all() 이라는 query가 DB로 100번 날라간다는 의미이다.

하지만 두번째 경우에서처럼 **prefetch_related** 를 쓰게 된다면, 이 부분을 엄청나게 효율적으로 개선할 수 있다. Person.objects.all()라는 query가 동일하게 실행됨과 동시에 self.language_set.all() 이라는 query가 별도로 실행돼 받아온 data들이 cache에 저장되게 된다. 그래서 person의 수 만큼 person.language_set.all()이 실행되더라도 DB에 접근하지 않고 cache에서 찾아서 쓰게 된다. 따라서 결과적으로 2개의 query만으로 아까와 똑같은 결과를 내게 된다.

여기까지만 보면 모든 relationships에서 사용할 수 있는 **prefetch_related** 가 더 좋아보이고, **prefetch_related** 로 할 수 있는 것을 굳이 **select_related** 를 사용해야되나 라는 아직 의문이 든다.
하지만 이 외에 두 함수가 동작하는 방식에도 중요한 차이점이 있다. 위에서 잠깐 설명하긴 했지만, **prefetch_related** 은 원래의 main query가 실행된 후 별도의 query를 따로 실행하게 된다. 반면, **select_related** 은 하나의 query만으로 related objects들을 다 가져온다.



```
Pet.objects.prefetch_related('person') # 2 querie
```

```
Pet.objects.select_related('person') # 1 query
```



 즉, 완벽히 동일한 결과라도 **prefetch_related** 를 쓰느냐, **select_related** 를 쓰느냐에 따라 query의 수가 달라진다. 아래의 예는**prefetch_related** 와 **select_related** 를 어떻게 적절히 사용해야 하는지를 잘 보여준다.



```
Pet.objects.prefetch_related('person__language_set')
```

위의 코드는 **prefetch_related**만 사용하였고, 결과적으로 3개의 query가 순차적으로 실행하게 된다.

1. Pet의 모든 instance를 가져오기 위한 query

2. 그 Pet instace들의 person을 가져오기 위한 query

3. 그 person들의 language_set을 가져오기 위한 query

   

여기에 __select_related__를 적절히 사용하면 query 수를 더 줄일 수 있다.

```
Pet.objects.select_related('person').prefetch_related('person__language_set')
```

**select_related** 에서 이미 person에 대한 data까지 모두 가져왔으므로, **prefetch_related** 에서 person은 cache를 통해 가져오고, laguage_set만 DB에서 fetch해오면 된다. 따라서 총 2개의 query만 실행된다.



1. Pet의 모든 instance와 그 intance의 person을 가져오는 query
2. 그 person들의 language_set을 가져오기 위한 query



# 결론

*many-to-many* , *many-to-one* 과 같은 relationships에서는 어쩔 수 없이 **prefetch_related** 를 사용하여야겠지만, *foreign-key* , *one-to-one* 와 같은 single-valued relationships이 있는 곳에서는 최대한 **select_related** 를 사용하여 query 수를 줄여주는 것이 효과적일 것 같다. 또 cache가 되는 과정을 잘 판단하여 어떻게 하면 DB에 접근하는 것을 최소로 할 수 있을까에 대해 항상 끈임없이 고민하여야 할 것 같다.



출처:  [select_related와 prefetch_related](https://jupiny.com/2016/10/06/select_related-prefetch_related/)







# bulk data 다루기

https://brownbears.tistory.com/464

대부분 many=True로 해결된다. 단 필드의 관계 설정이 잘 되어있을 경우



## 공부할거

### 1. ORM Query 순서 및 최적화

### 2. Serializer 

​	https://seulcode.tistory.com/199





## Check Validation 구현

InputWrap.js   (forwardRef사용)

```react
const MyInput = styled.input`
  ::placeholder {
    color: ${ST_GRAY};
    font-size: 15px;
    font-weight: 300;
  }

  width: ${(props) => (props.name ? "80%" : "100%")};
  height: 100%;
  padding-left: 5px;
  border: solid 1px ${ST_SEMI_YELLOW};
  border-radius: 6px;

  ${(props) => (props.cursor ? `cursor: ${props.cursor}` : null)};

  &:focus {
    outline: none;
    border: solid 1px ${MAIN_COLOR};
  }

  &.valid-value {
    background-size: 18px;
    background-repeat: no-repeat;
    background-image: url("static/img/icons/check-valid.png");
    background-position: 94% center;
  }

  &.invalid-value {
    border: solid 1px ${ST_RED};
  }

`;

//... 생략
export default React.forwardRef((props, ref) => (<InputWrap {...props} innerRef={ref}/>));
```



AddGroup.js  (InputWrap을 import하여 사용한 예시)

```react
import React, { Fragment, useState, useCallback, createRef } from "react";
import InputWrap from "../../../../A-Atomics/Form/InputWrap"
//생략
function AddGroup(props) {
  const [groupname, setGroupName] = useState(null);
  const [isValid, setIsValid] = useState(null);
  const inputRef = createRef(null);

  const handleChange = useCallback((e) => {
    let value = e.target.value;
    checkValidation(value);
    setGroupName(value);
  });

  const checkValidation = (groupname) => {
    inputRef.current.classList.remove("valid-value", "invalid-value");
    if(groupname !=""){
      let res = !props.groups.some(group => group.groupname === groupname);
      
      //valid state 저장
      setIsValid(res);
      
      //css 적용
      if( res ) inputRef.current.classList.add("valid-value");
      else inputRef.current.classList.add("invalid-value");
      // inputRef.current.style.backgroundColor = "red";
    } 
  };
  
  //..생략.. 
   return (
    	<Wrap>
          <InputWrap
          height = "55px"
          label="Name"
          name="GroupName"
          desc="Group Name"
          onChange={handleChange}
          enterHandler={checkValidation}
          ref={inputRef}
          />
       </Wrap>
	)
          
```

