# simtime 개발일지

#### 1. App은 어떻게 나누는 것이 좋을까? 



#### 2. 초대장(Invitation) 의 guests의 자료형은?

NoSQL방식을 굳이 모방하여 ArrayField로 지정하려다 보니, foreign key여야하는 value들이라 고민이 생겼다



**ManyToMany relation** 는 RDBMS이 일반적인 다대다 관계. django model에서 구현가능하다.

> ★ https://stackoverflow.com/questions/16554335/best-method-to-store-list-of-foreign-keys-in-a-model
>
> - : https://docs.djangoproject.com/en/dev/ref/models/fields/#manytomanyfield
>
>   
>
> 실제 반영 소스
>
> ```
> 
> ```
>
> 



NoSQL에선 어떻게 구현하는지 더 알아봤다.

##### NoSQL 방식 ?

https://blog.outsider.ne.kr/655



### 3. Customize Table Name. Table명 고치기

**문제** :  Migrate 시 자동으로 appName_ClassName 으로 prefix 붙는거 싫다.

**해결** : https://stackoverflow.com/questions/9849666/how-to-remove-the-prefix-of-a-table-for-a-django-model



####  Meta에 db_table

```python
class Invitation(models.Model):
    host = models.CharField(max_length=50)
    status = models.CharField(max_length=50,
                              choices=EventStatus.choices,
                              default=EventStatus.OPEN)
    event_at = models.DateTimeField(blank=False)
    guests = ArrayField(models.CharField(max_length=50, blank=True))
    message = models.CharField(max_length=500, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "Invitation"
```



#### 모델명 지어주는 class 생성! 

모델마다 Meta 클래스 지정하지 않아도 된다!

```python
class MyModelBase( ModelBase ):
    def __new__( cls, name, bases, attrs, **kwargs ):
        if name != "MyModel":
            class MetaB:
                db_table = "FOO_" + name

            attrs["Meta"] = MetaB

        r = super().__new__( cls, name, bases, attrs, **kwargs )
        return r       

class MyModel( Model, metaclass = MyModelBase ):
    class Meta:
        abstract = True

class Businesses( MyModel ):
    ...
```

```python


class CustomizedModelBase(models.base.ModelBase):
    def __new__(cls, name, bases, attrs, **kwargs):
        if name != "CustomizedModel":
            class MetaB:
                db_table = name

            attrs["Meta"] = MetaB

        r = super().__new__(cls, name, bases, attrs, **kwargs)
        return r


class CustomizedModel(models.Model, metaclass=CustomizedModelBase):
    class Meta:
        abstract = True


# Create your models here.
class EventStatus(models.TextChoices):
    CLOSED = 'Not available anymore'
    OPEN = 'Available to join'
    PENDING = 'Pending (not available for a while)'


class Invitation (CustomizedModel):
    host = models.CharField(max_length=50)
    status = models.CharField(max_length=50,
                              choices=EventStatus.choices,
                              default=EventStatus.OPEN)
    event_at = models.DateTimeField(blank=False)
    guests = ArrayField(models.CharField(max_length=50, blank=True))
    message = models.CharField(max_length=500, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

```





### 4. django의 APPEND_SLASH에러

http://codingdojang.com/scode/377

* 브라우저에서 요청한 URL이 urls.py 파일안에 정의된 패턴과 일치하는 것이 없을때만 붙여서 다시 한번 일치하는 것이 있나 검사. 없으면 404 Error