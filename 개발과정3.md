# Simtime 개발일지 3

## Kakao Map api 이용하기

### MAP - Atomic 구성하기

```js
/*global kakao*/
import React, { useState, useEffect } from "react";
import styled from "styled-components";
import PropTypes from "prop-types";

const MapWrap = styled.div`
  width: ${(props) => (props.width ? props.width : "100%")};
  height: ${(props) => (props.height ? props.height : "150px")};
`;

function Map(props) {
  const { lat, lng, hight, width, mapId } = props;

  const [loadMap, setLoadMap] = useState(false);
  // const [mapLat, setLat] = useState(lat);
  // const [mapLng, setLng] = useState(lng);

  useEffect(() => {
    var eventLocation = new kakao.maps.LatLng(lat, lng);

    kakao.maps.load(() => {
      let container = document.getElementById(mapId);
      let options = {
        center: eventLocation,
        level: 7,
      };

      const map = new window.kakao.maps.Map(container, options);
      const marker = new kakao.maps.Marker({
        position: eventLocation,
      });

      marker.setMap(map);
    });
  }, []);

  return <MapWrap {...props} id={mapId}></MapWrap>;
}

export default Map;

Map.propTypes = {
  height: PropTypes.string,
  width: PropTypes.string,
  lat: PropTypes.number,
  lng: PropTypes.number,
  mapId: PropTypes.string,
};

Map.defaultProps = {
  height: "50%",
  width: "100%",
  lat: 37.506502,
  lng: 127.053617,
  mapId: "myMap",
};

```

![map01](https://github.com/arara90/images/blob/master/Simtime/simtime_017.png?raw=true)

여기서 주의할 점은 반드시 mapId를 전달하는 것이 좋다. 그림과 같이 두 개의 지도가 쓰이는 상황에서 원하는 지도에 해당하는 곳에서만 작업을 해야한다. 만약 mapId가 동일하면 덮어씌워지므로 어차피 한쪽만 나올 것이다...





### 주소 검색 자동완성

 포털 검색이나 카카오 지도에 직접 들어가서 주소 검색 시 볼 수 있는 키워드 입력시 실시간으로 자동완성된 목록을 보여주는 기능을 구현하고자 했다. 하지만 찾아본 결과 카카오에서는 해당 api를 지원하지 않는다. 

아쉽지만 엔터 키 이벤트 발생 후 데이터를 받아와서 목록을 받아오는 방식으로 우선 구현하자.

참고로 구글은 가능하다. (https://developers.google.com/places/web-service/autocomplete?hl=ko) 



(추가) 해당 API(자동완성)없어도 충분히 가능하다. handleChange에서 들어올때마다 새로운 목록을 받아오면 된다.

```js
import React, { useState, useCallback, useRef } from "react";
import axios from "axios";
import styled from "styled-components";
import PropTypes from "prop-types";
import Paragraph from "..//Font/Paragraph";

//...생략

function SearchBox(props) {
//...생략
  const startSearch = (keyword) => {
    return new Promise(function (resolve, reject) {
      resolve(search(keyword));
    });
  };

  const handleChange = (e) => {
    var val = e.target.value;
    setCurrOption(val);

    if (val.length > 0) {
      startSearch(val)
        .then((resolvedData) => {
          setOptionDatas(resolvedData.items);
        })
        .then(() => {
          console.log("then", optionDatas);
          setShowOptions(true);
        });
    }
  };

  const changeShowOptions = () => {
    setShowOptions(!showOptions);
  };

  const changeSelectedOptions = (option) => {
    setShowOptions(!showOptions);
    setSelectedOption(option);
  };

  const renderOptions = (options) => {
    return (
      <OptionWrap
        width={width}
        top={height}
        contentHeight={
          parseInt(height.replace(/[^0-9]/g, "")).toFixed(0) * options.length +
          2 +
          "px"
        }
        showOptions={showOptions}
        onBlur={changeShowOptions}
      >
        {optionDatas.map((option) => {
          return (
            <Option
              height={height}
              key={option.id + option.name}
              isSelected={option.id === selectedOption}
              onClick={() => changeSelectedOptions(option)}
            >
              {option.name}
            </Option>
          );
        })}
      </OptionWrap>
    );
  };

  return (
    <Wrap {...props}>
      <Select
        ref={refName}
        type="text"
        autoComplete="off"
        onChange={handleChange}
        width={width}
        height={height}
        name={name}
        arrow={arrow}
        cursor={cursor}
        value={currOption.name}
      />
      {renderOptions(optionDatas)}
    </Wrap>
  );
}

export default SearchBox;

SearchBox.propTypes = {
  width: PropTypes.string,
  height: PropTypes.string,
  options: PropTypes.array,
  defaultOption: PropTypes.object,
  arrow: PropTypes.bool,
  cursor: PropTypes.string,
};

SearchBox.defaultProps = {
  width: "100%",
  height: "100%",
  options: [{ id: 0, name: "" }],
  defaultOption: null,
  arrow: false,
  cursor: "pointer",
};

```



### Kakao map - 키워드로 장소 검색하기

[Kakao-map-API-키워드로 장소검색하기](http://apis.map.kakao.com/web/sample/keywordBasic/) 를 이용한 장소 검색 구현.

```js
// Simtime/frontend/src/actions/mapApi.js

import axios from "axios";

const KAKAO_API_KEY = "secret";
const URL = "https://dapi.kakao.com/v2/local/search/keyword.json"; 

const client = axios.create({
  baseURL: `${URL}`,
  headers: {
    "Content-Type": "application/json; charset=utf-8",
    Authorization: `KakaoAK ${KAKAO_API_KEY}`,
  },
  timeout: 10000, // 타임아웃 10초
});

export const searchPlaces = (
  query = "투썸",
  //   category_group_code = null,
  //   x = "",
  //   y = "",
  //   radius = "",
  //   rect = "",
  page = 1,
  size = 10,
  sort = "accuracy"
) => {
  const params = {
    query, //검색을 원하는 질의어
    page, //결과 페이지 번호, 1-45 사이, 기본 값 1
    size, //한 페이지에 보여질 문서의 개수, 1~15 사이, 기본 값 15
    sort, //accuracy, recency
  };
  return client
    .get("", {
      params,
    })
    .then(({ status, statusText, data }) => {
      if (status === 200) {
        const {
          meta: {
            is_end, // 현재 페이지가 마지막 페이지인지 여부(false이면 다음 페이지를 요청할 수 있음)
            pageable_count, // 검색 결과로 제공 가능한 문서수
            total_count, // 전체 검색된 문서수
          },
          documents,
        } = data;

        const result = {
          isEnd: is_end,
          pageableCount: pageable_count,
          totalCount: total_count,
          items:
            documents && documents.length
              ? documents.map(
                  (
                    {
                      address_name,
                      category_group_code,
                      category_group_name,
                      category_name,
                      distance,
                      id,
                      phone,
                      place_name,
                      place_url,
                      road_address_name,
                      x,
                      y,
                    },
                    index
                  ) => {
                    return {
                      id: id,
                      name: place_name,
                      desc: road_address_name,
                      place_id: id,
                      place_url,
                      lan: x,
                      lat: y,
                      address: road_address_name,
                    };
                  }
                )
              : [],
        };
        return result;
      } else {
        throw new Error(`${status}:${statusText}`);
      }
    });
};

```

https://anpigon.github.io/blog/kr/@anpigon/react-native-api/

[API TEST PAGE](https://developers.kakao.com/tool/rest-api/open/v2/local/search/keyword.json/get)





### Map - 새롭게 받아온 좌표로 maker찍기

* **문제** : 사용자가 요청한 위치를 받아 지도 위에 marker를 찍어줘야한다.  여기서 javascript로 선언한 map객체에 접근할 필요성이 생겼다. 특히 한 페이지에 두 개의 MAP component를 사용하고 있었기 때문에 이를 각각 제어해야했다. 

  

* **해결** : 함수형이었던 Map Component를 Class형으로 바꾸고, Kakao Map 객체를 멤버 변수로 관리했다.

   처음엔 React의 Reference기능이 필요한가 했다. '외부 라이브러리와의 연동' 과 비슷한 키워드들과 자주 언급되는 Hook. 하지만 내가 필요한 js 객체 자체에 접근하기 위한 방법이 아닌  DOM이나 React 요소에 직접적으로 접근하기 위한 기능이었다. 그리고 이를 포기하자마자 의외로 빠르게 답을 얻을 수 있었다. 

  ```js
  import React, { Component } from "react";
  import styled from "styled-components";
  import PropTypes from "prop-types";
  
  export class Map extends Component {
    myMap = null;
    marker = null;
  
    constructor(props) {
      super(props);
    }
  
    componentDidMount() {
      this.loadMap();
    }
  
    componentDidUpdate(prevProps) {
      if (this.props.location !== prevProps.location) {
        this.marker.setMap(null); //기존 마커 삭제
        this.displayMarker(this.props.location);
      }
    }
  
    render() {
      return <MapWrap {...this.props} id={this.props.mapId}></MapWrap>;
    }
  
    displayMarker(location, map = this.myMap) {
      var eventLocation = new kakao.maps.LatLng(location.lat, location.lng);
      this.marker = new kakao.maps.Marker({
        position: eventLocation,
      });
      map.setCenter(eventLocation);
      this.marker.setMap(map);
    }
  
    loadMap() {
      var eventLocation = new kakao.maps.LatLng(
        this.props.location.lat,
        this.props.location.lng
      );
      var container = document.getElementById(this.props.mapId);
      var options = {
        center: eventLocation,
        level: 7,
      };
  
      kakao.maps.load(() => {
        container, options;
      });
  
      this.myMap = new window.kakao.maps.Map(container, options);
      this.displayMarker({
        lat: this.props.location.lat,
        lng: this.props.location.lng,
      });
    }
  }
  
  export default Map;
  
  const MapWrap = styled.div`
    width: ${(props) => (props.width ? props.width : "100%")};
    height: ${(props) => (props.height ? props.height : "150px")};
  `;
  
  Map.propTypes = {
    width: PropTypes.string,
    height: PropTypes.string,
    mapId: PropTypes.string,
    lat: PropTypes.number,
    lng: PropTypes.number,
    location: PropTypes.object
  };
  
  Map.defaultProps = {
    mapId: "myMap", // should be unique.
     location: { lat: 37.488376, lng: 126.752351 },
  };
  
  ```

  

   Map Class형 Component로 하고, location(마커를 찍을 위치 좌표)을 state으로 관리한다면 각각의 인스턴스가 새로운 location 데이터를 받을 때마다 본인의 map 객체 위에서 동작하게 된다.  함수형에서는 eval을 써서 변수명을 동적으로 제어해야하나 별의 별 생각을 다했는데.. 정말 간단한 해결법이었다. 

  > 대략 이런 고민들..
  >
  > useRef 
  >
  > 문제 : Map Component를 사용할 때마다 ref명을 각각 다르게 설정해야 정확한 접근이 가능하다..
  >
  > - [forwardref-를-사용하여-하위-컴포넌트의-함수-내보내기](https://medium.com/react-native-seoul/imperativehandle-과-forwardref-를-사용하여-하위-컴포넌트의-함수-내보내기-55bbf9427559)

  

   사실 **함수형과 클래스형**을 딱히 구분해서 사용하고 있지 않았는데.. 드디어 한가지 차이를 알게된 것 같다. 이런 경우 함수형이 좀 더 까다롭게 느껴진다. 물론 나의 역량 부족일 수도 있겠지만.. 객체지향언어(C++, JAVA)의 사고가 익숙한 나로서는 이 방법이 매우 직관적으로 느껴진다.

  

   그리고 여기서 공부한 ref는 그 다음날 Tag 입력창을 구현하는데 큰 도움이 됐다. ref를 사용함에 있어 서도 함수-클래스형 Component의 차이가 발생했다. 그놈의 this..!!.. 

  

* **잡담** : google이나 naver map은 react 라이브러리를 따로 제공하는데 Kakao는...ㅠ.ㅠ 더 열심히 개발역량을 키우라는 뜻이겠져..ㅠㅠ .. 여하튼, 굳이굳이 kakao를 고집하는 이유는 아무래도 Simtime의 성격상 완벽한 Kakao와의 연동을 목표로 하고 있기 때문이다. 

   뭔가 해결하고 나면 너무 간단해서 고민한 시간이 부끄럽고 자괴감도 들지만.... 그래도 쉬운 길을 보고도 돌아가지 않고 내가 세운 Simtime 서비스 철학?!(이라기보단 소소함 야망...ㅋㅋㅋㅋㅋㅋ)을 지켜낸 것엔 오늘도 뿌듯함을 느껴본다. 



### 자동완성 선택창 state 또는 css로 제어하기

```js

const Select = styled.input`
  padding-left: 4px;
  border: solid 1px ${ST_SEMI_YELLOW};
  border-radius: 6px;

  width: ${(props) => props.width};
  height: ${(props) => props.height};
  line-height: ${(props) => props.height};

  font-size: 15px;
  font-weight: 400;

  cursor: ${(props) => props.cursor};

  ${(props) =>
    props.arrow
      ? `  
  background-size: 15px;
  background-repeat: no-repeat;
  background-image: url("static/img/icons/arrow-down2.png");
  background-position: 88% center;`
      : null};
`;

const OptionWrap = styled.div`
  padding: 1px 1px 1px 1px;
  background-color: white;
  display: none;


//css이용
	${Select}:focus ~ & {
    display: block;
  }

//showOptions state이용

  // ${(props) => (props.showOptions ? null : "display: none")};
  
  width: ${(props) => props.width};
  height: ${(props) => props.contentHeight};
  max-height: 160px;

  position: absolute;
  top: ${(props) => props.top};
  left: 0px;

  font-size: 15px;
  font-weight: 400;
  z-index: 9999;

  overflow-x: hidden;
  overflow-y: auto;

  &::-webkit-scrollbar {
    width: 10px;
  }

  &::-webkit-scrollbar-thumb {
    background-color: ${ST_SEMI_YELLOW};
    border-radius: 10px;

    &:hover {
      background-color: ${ST_GRAY};
    }
  }

  &::-webkit-scrollbar-track {
    background-color: ${ST_SEMI_GRAY};
    border-radius: 5px;
    box-shadow: inset 0px 0px 3x white;
  }
`;

```

* css 이용 시에 Option의 OnClick 버튼이 제대로 동작하지 않는 문제에 봉착하여 다시 state로 돌아갔다.

  하지만 css가 동작이 훨씬 자연스러워 졌고 다른 component에 focus가 옮겨갔을때 잘 닫힌다.  조금 더 공부해서 되도록이면 css를 사용할 수 있도록 보완해야할 필요가 있다.



# Django-JavaScript 연동

### 문제: django settings.py 에 환경변수들을 javasript에서도 동일하게 불러와 쓰고 싶다.

 즉, App_key와 같은 정보를 담고있는 secret.json 파일로부터 값을 어떻게 받아와 사용하는것이 효율적일까?



참고 1 : https://hyunalee.tistory.com/62







5/20

: DatePicker 닫기 기능 추가

: 현재 위치 받아와서 초기화

: 이미지 올리기 (S3) 구축 및 기능 완성



5/21

Event Maker 마무리

5/22 

login / register 화면 완성

=========================================

from 5/25(월)~  -----invitation

친구 Model

* 그룹별 관리

- 친구 모두에게 invitation 날려보기

* 받은 invitaion 달력에 표시
* events filter (나의 event, 내가 참여한 event,  원하는 친구 필터링해서 보기)

* 내 eveventet 관리 (모두 보기(목록형 관리), 수정, 삭제)
* invitation 관리 ((목록형 관리) ,참여, 삭제)

==================================================